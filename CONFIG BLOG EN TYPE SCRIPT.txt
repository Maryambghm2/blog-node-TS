CONFIG BLOG EN TYPE SCRIPT /


crée fichier tsconfig.json 

Pour express :

npm install --save-dev @types/express

Pour type script 
npm i -D typescript @types/node

Pour cors : 
npm install --save-dev @types/cors


Pour express session :
npm install --save-dev @types/express-session


Pour PostgreSQL : 

npm install --save-dev @types/pg


LIGNE Général :
npm install --save-dev @types/express @types/cors @types/express-session @types/pg



Db.ts : 

import { Pool, QueryConfigValues, QueryResultRow} from 'pg'
import dotenv from 'dotenv';
dotenv.config({ path: './.secrets' });

const pool = new Pool({
    user: process.env.POSTGRES_USER,
    password: process.env.POSTGRES_PASSWORD,
    host: process.env.POSTGRES_HOST,
    port: process.env.POSTGRES_PORT ? parseInt(process.env.POSTGRES_PORT) : 5432,
    database: process.env.POSTGRES_DATABASE
});



// Condition Ternaire (? :)  pour le port ::

Vérifie si process.env.POSTGRES_PORT a une valeur définie (c'est-à-dire qu'elle n'est pas undefined, null, ou une chaîne vide).
Si process.env.POSTGRES_PORT a une valeur, elle est convertie en nombre entier avec parseInt(process.env.POSTGRES_PORT).
Si process.env.POSTGRES_PORT n'a pas de valeur, le port par défaut de PostgreSQL, qui est 5432, est utilisé.
//



 async function query<T extends QueryResultRow = any, I = any[]>(q: string, v?: QueryConfigValues<I>) {
    try {
        return await pool.query<T, I>(q, v);
    } catch (err) {
        throw err;
    }
}

export default query 


Explication type généraux :

export async function query<T extends QueryResultRow = any, I = any[]>(q: string, v?: QueryConfigValues<I>) :

<T extends QueryResultRow = any, I = any[]> :
T extends QueryResultRow = any : Type générique T pour les lignes de résultats de la requête. 
T est un type qui doit être une sous-classe de QueryResultRow (ou QueryResultRow lui-même). 
Par défaut, T est any, ce qui signifie que si vous ne spécifiez pas de type, les résultats seront de type any.
I = any[] : Type générique I pour les paramètres de la requête. Par défaut, I est un tableau de type any, ce qui permet de passer des paramètres de n'importe quel type.


q: string :

q : La requête SQL à exécuter, passée en tant que chaîne de caractères.
v?: QueryConfigValues<I> :

v : Paramètres optionnels pour la requête SQL. QueryConfigValues<I> est un type pour les options de requête, où I est le type des paramètres.
try { return await pool.query<T, I>(q, v); } :

await pool.query<T, I>(q, v) : Exécute la requête SQL en utilisant le pool de connexions. Le type T est utilisé pour typifier les lignes de résultat, et I est utilisé pour les paramètres de la requête.

Types Généraux : La fonction utilise des types génériques pour permettre une flexibilité maximale dans le typage des résultats et des paramètres de requête. T est le type des lignes de résultat, et I est le type des paramètres de la requête.

Crud.ts : 

// CRUD 
import express, { Request, Response } from 'express';

// HACHAGE
import argon2 from 'argon2'

import cors from 'cors';
// TRAITEMENT DU PARSER 
import bodyParser from 'body-parser';

import query from './db';

const app = express();
const port = 8080;

// middleware bodyparser ;Dire au système qu'il s'agit d'un json
app.use(bodyParser.json());


// POUR RECUPERER IMAGE 
app.use(cors());
app.use('/pic', express.static('public/pic'));



// CHEMINS : 

// CHEMIN ROOT DE BASE ;RACINE 
app.get('/', (req: Request, res: Response) => {
    res.send("Bienvenue sur l'API Blog !");
});

// CHEMIN  USERS 
// get pour users
app.get('/users', async (req: Request, res: Response) => {
    
    try {
        // Param requete username 
        const { username } = req.query;

        // REQUETE SQL DE BASE 
        let queryReq: string = 'SELECT * FROM users';
        let queryParams: any[] = [];


        if (username) {
            queryReq += ' WHERE username = $1';
            queryParams.push(username);
        }

        const result = await query(queryReq, queryParams);

        // Envoi reponse 
        res.send(result.rows);
    } catch (error) {
        console.error('Erreur lors de la récupération des utilisateurs :', error);
        res.status(500).send('Erreur serveur');
    }

});


// Get pour un user spécifique PAR ID
app.get('/users/:id', async (req: Request, res: Response) => {
    const id = parseInt(req.params.id);
    // console.log('id:', id);


    // SI valeur 'id' invalide 
    if (isNaN(id)) {
        return res.status(400).send("L'id doit être un entier");
    }
    try {
        // Constante récupération de l'utilisateur dans le tableau 
        const result = await query('SELECT * FROM users WHERE id_user = $1', [id]);
        // Verif si l'utilisateur existe 
        if (result.rowCount === 0) {
            return res.status(404).send(`L'id ${id} n'a pas été trouvé`);
        } else {
            return res.send(result.rows[0]);
        }
    } catch (err) {
        console.error("Erreur", err)
        res.status(500).send("Erreur serveur");
    }
});

// Get pour récuperer les articles d'un user spécifique
app.get('/articles/users/:id', async (req: Request, res: Response) => {
    const id = parseInt(req.params.id);

    if (isNaN(id)) {
        return res.status(400).send("L'ID de l'utilisateur doit être un entier valide.");
    }
    try {
        // REQUETE POSTGRESQL
        const reqQuery = `SELECT a.*, u.username, u.mail FROM articles a
         JOIN users u on a.author =  u.id_user
         WHERE a.author = $1`;

        const result = await query(reqQuery, [id]);

        // Vérifier si l'user à des articles associée à lui 
        if (result.rowCount === 0) {
            return res.status(404).send('Aucun article trouvé pour cet utilisateur');
        }
        return res.send(result.rows);

    } catch (err) {
        console.error("Erreur", err)
        res.status(500).send("Erreur serveur");
    }
});

// POST USERS INSCRIPTION
app.post('/users/register', async (req: Request, res: Response) => {
    const { username, mail, password } = req.body


    // VERIF CHAMPS VIDE 
    if (!username || !mail || !password) {
        return res.status(400).send("Tout les champs sont obligatoires.");
    }

    // USERNAME :
    // VERIF USERNAME UTILISER
    try {
        const usernameCheck = await query('SELECT username FROM users WHERE username = $1', [username]);
        if (usernameCheck.rowCount !== null && usernameCheck.rowCount > 0) {



// if (usernameCheck.rowCount !== null && usernameCheck.rowCount > 0) 
// Si username check non nul et supérieur à 0 

AUTRE METHODE 
// if ((usernameCheck.rowCount ?? 0) > 0)
// L'opérateur ?? sert fournir une valeur par défaut à rowCount il est null ou undefined :
//
//


        return res.status(400).send("Le nom d'utilisateur est déjà pris, veuillez en choisir un autre.");
    }
    // VERIF LONGUEUR USERNAME 
    else if (username.length < 3 || username.length > 25) {
        return res.status(400).send("Le nom d'utilisateur doit contenir entre 3 et 25 caractères.");
    }

    // PASSWORD :
    // VERIF PASSWORD REGEX
    const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[#?!@$ %^&*-]).{8,}$/;
    if (!passwordRegex.test(password)) {
        return res.status(400).send("Le mot de passe doit comporter au moins 8 caractères et inclure au moins: une majuscule, une minuscule, un chiffre et un caractère spécial.")
    }
    // VERIF LONGUEUR PASSWORD 
    else if (password.length > 100) {
        return res.status(400).send("Le mot de passe est trop long (maximum 100 caractères).");
    }

    // MAIL :
    // REGEX VERIF MAIL 
    const mailRegex = /^[\w\-\.]+@([\w-]+\.)+[\w-]{2,}$/;
    if (!mailRegex.test(mail)) {
        return res.status(400).send("Le format de l'email est invalide.")
    }
    // VERIF LONGUEUR MAIL 
    else if (mail.length > 255) {
        return res.status(400).send("L'email est trop long (maximum 255 caractères).");
    }
    // VERIF MAIL UTILISER
    const mailCheck = await query('SELECT mail FROM users WHERE mail = $1', [mail]);
    if (mailCheck.rowCount !== null && mailCheck.rowCount > 0) {
        return res.status(400).send("L'email est déja utilisé, veuillez en insérer un autre.")
    }


// if (mailCheck.rowCount !== null && mailCheck.rowCount > 0) 
// Si mail check non nul et supérieur à 0 

AUTRE METHODE 
// if ((mailCheck.rowCount ?? 0) > 0)
// L'opérateur ?? sert fournir une valeur par défaut à rowCount il est null ou undefined :
//
//

    
        const hashedPassword = await argon2.hash(password);

        const result = await query('INSERT INTO users (username, mail, password) VALUES ($1, $2, $3) RETURNING *', [username, mail, hashedPassword]);
        res.status(201).send(result.rows[0]);

    } catch (error) {
        console.error("Erreur", error)
        res.status(500).send("Erreur serveur");
    }
});

// ROUTE CONNEXION 
app.post('/users/login', async (req: Request, res: Response) => {
    const { mail, password } = req.body

    try {
        // RECHERCHE USER PAR EMAIL 
        const result = await query('SELECT * FROM users WHERE mail = $1', [mail]);
        const user = result.rows[0];

        // SI USER N'EXISTE PAS 
        if (!user) {
            return res.status(400).send("L'email est incorrect ou ne correspond à aucun compte.");
        }

        // VERIF CHAMPS VIDE 
        if (!mail || !password) {
            return res.status(400).send("L'email et le mot de passe sont requis.");
        }
        // REGEX VERIF MAIL 
        const mailRegex = /^[\w\-\.]+@([\w-]+\.)+[\w-]{2,}$/;
        if (!mailRegex.test(mail)) {
            return res.status(400).send("Le format de l'email est invalide.")
        }

        // VERIF PASSWORD REGEX
        const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[#?!@$ %^&*-]).{8,}$/;
        if (!passwordRegex.test(password)) {
            return res.status(400).send("Le mot de passe doit comporter au moins 8 caractères et inclure au moins: une majuscule, une minuscule, un chiffre et un caractère spécial.")
        }

        // Comparaison mot de passe donné et ceux qui sont hachés
        const passwordMatch = await argon2.verify(user.password, password);

        // SI MOT DE PASSE NE CORRESPOND PAS 
        if (!passwordMatch) {
            return res.status(400).send("Mot de passe incorrect.")
        } else {
            res.status(200).send(`Connexion réussie, bienvenue ${user.username}`);
        }
    } catch (error) {
        console.error("Erreur", error)
        res.status(500).send("Erreur serveur");
    }
});

// CHEMIN POUR TOUT LES ARTICLES 
app.get('/articles', async (req: Request, res: Response) => {

    try {
        const reqQuery = `SELECT a.id, a.title, a.content, a.created_at, a.picture, 
        u.username AS author
 FROM articles a
 JOIN users u  ON a.author = u.id_user`;

        const result = await query(reqQuery);

        // console.log("Articles recu:", result.rows);
        return res.status(200).send(result.rows);
    } catch (error) {
        console.error("Erreur lors de la récupération des articles :", error);
        res.status(500).send("Erreur serveur");
    }
});

// CHEMIN ARTICLE SPECIFIQUE PAR ID 
app.get('/articles/:id', async (req: Request, res: Response) => {
    const id = parseInt(req.params.id);

    // SI valeur 'id' invalide 
    if (isNaN(id)) {
        return res.status(400).send("L'ID de l'article doit être un entier valide.");
    }

    try {
        // Constante récupération de l'utilisateur dans le tableau 
        const result = await query(
            `SELECT a.id, a.title, a.content, a.created_at, a.picture, a.author AS author_id,
                    u.username AS author 
             FROM articles a
             JOIN users u ON a.author = u.id_user 
             WHERE a.id = $1`,
            [id]
        );

        // Verif si l'utilisateur existe 
        if (result.rowCount === 0) {
            return res.status(404).send(`Aucun article trouvé avec l'ID ${id}.`);
        } else {
            res.send(result.rows[0]);
        }
    } catch (error) {
        console.error("Erreur lors de la récupération de l'article :", error);
        res.status(500).send("Erreur serveur");
    }
});


// POST pour crée un article 
app.post('/articles', async (req: Request, res: Response) => {
    const { title, content, picture, author } = req.body;

    if (!title || !content || !author) {
        return res.status(400).send("Tous les champs (titre, contenu, auteur) sont obligatoires.")
    }
    
    try {
        let authorId = parseInt(author);
        if (isNaN(authorId)) {
            // RECHERCHE PAR USERNAME SI CHAINE CARACTERE
            const authorCheckByUsername = await query('SELECT id_user FROM users WHERE username = $1', [author]);
            if (authorCheckByUsername.rowCount === 0) {
                return res.status(400).send(`L'auteur spécifié par le nom d'utilisateur "${author}" n'existe pas.`);
            }
            authorId = authorCheckByUsername.rows[0].id_user;
        } else {
            const authorExist = await query('SELECT FROM users WHERE id_user = $1', [authorId]);
            if (authorExist.rowCount === 0) {
                return res.status(400).send(`L'auteur spécifié pour l'id (${authorId}) n'existe pas.`);
            }
        }

        // console.log('title:', title, ', content:', content, ', picture:', picture || null, ', author:', authorId);

        // INSERTION NOUVELLE ARTICLE 
        const result = await query('INSERT INTO articles (title, content, created_at, picture, author) VALUES ($1, $2, NOW(), $3, $4) RETURNING *',
            [title, content, picture || null, authorId]);
        res.status(201).send(result.rows[0]);

    } catch (error) {
        console.error("Erreur lors de l'ajout de l'article :", error);
        res.status(500).send("Erreur serveur");
    }
});



app.listen(port, () => {
    console.log("Serveur en ligne dans le port 8080 !");
});
